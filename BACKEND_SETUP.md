# Backend Setup & Implementation Playbook

This document is the single source of truth for preparing and delivering the Broad backend. It covers environment prep, scaffolding, feature requirements, shared contracts, and concrete code examples so another engineer or agent can implement the system end-to-end without additional context.

---

## Accounts & Tooling Prerequisites
1. GitHub account with ability to create repositories.
2. Supabase project (free tier is sufficient to start).
3. Vercel ("Wursel") account on the Hobby plan.
4. Node.js 18+ and npm installed locally.
5. Optional but recommended: Supabase CLI (`npm install -g supabase`).

---

## 1. Create the Backend Repository
1. Create a new GitHub repo named something like `broad-backend` (no template).
2. Clone alongside the Expo frontend (e.g. `/Users/pallav/Desktop/Projects/broad-backend`).
3. Initialize with:
   - `npm init -y`
   - `.gitignore` from GitHub's Node preset.
4. Commit/push the clean scaffold. Share the exact local path when ready.

---

## 2. Prepare Supabase
1. Create a Supabase project and note the autogenerated database password (keep private).
2. Collect values:
   - `SUPABASE_URL`
   - `SUPABASE_ANON_KEY`
   - `SUPABASE_SERVICE_ROLE_KEY` (never expose publicly; store locally and in Vercel secrets only).
3. Optionally run `supabase init` inside the backend repo to bootstrap `supabase/config.toml` and `supabase/migrations/`.
4. Enable **Email OTP** in Authentication → Providers. Disable unused providers for now.
5. Ensure Database → Replication → `Realtime` switch is enabled so changefeeds are available.

---

## 3. Seed Initial Database Structure
Execute SQL in the Supabase SQL editor (or place scripts under `supabase/migrations/000000_init.sql`). Example starter script:

```sql
create extension if not exists "uuid-ossp";

create table if not exists public.profiles (
  id uuid primary key references auth.users on delete cascade,
  handle text unique,
  display_name text not null,
  bio text,
  avatar_url text,
  country_code text,
  phone_number text,
  expo_push_token text,
  role text default 'rider',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists public.rides (
  id uuid primary key default uuid_generate_v4(),
  creator_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  tagline text,
  route_summary text,
  starts_at timestamptz not null,
  meetup_location jsonb,
  pace text,
  experience_level text,
  max_riders int default 10,
  status text default 'scheduled',
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists public.bookings (
  id uuid primary key default uuid_generate_v4(),
  ride_id uuid not null references public.rides(id) on delete cascade,
  rider_id uuid not null references public.profiles(id) on delete cascade,
  status text default 'confirmed',
  created_at timestamptz default now()
);

create table if not exists public.driver_locations (
  id uuid primary key default uuid_generate_v4(),
  ride_id uuid not null references public.rides(id) on delete cascade,
  driver_id uuid not null references public.profiles(id) on delete cascade,
  position geography(point, 4326),
  speed numeric,
  heading numeric,
  updated_at timestamptz default now()
);

create table if not exists public.garages (
  id uuid primary key default uuid_generate_v4(),
  owner_id uuid not null references public.profiles(id) on delete cascade,
  label text not null default 'Main Garage',
  created_at timestamptz default now()
);

create table if not exists public.motorcycles (
  id uuid primary key default uuid_generate_v4(),
  garage_id uuid not null references public.garages(id) on delete cascade,
  make text not null,
  model text not null,
  year int,
  nickname text,
  vin text unique,
  odometer_km numeric,
  last_serviced_at date,
  deleted_at timestamptz,
  created_at timestamptz default now()
);

create table if not exists public.maintenance_logs (
  id uuid primary key default uuid_generate_v4(),
  motorcycle_id uuid not null references public.motorcycles(id) on delete cascade,
  performed_at date not null,
  description text not null,
  cost numeric,
  notes text,
  created_at timestamptz default now()
);
```

Add simple RLS policies granting access to the service role; more granular policies will be defined during implementation. Export the SQL or keep the migration file ready for version control.

---

## 4. Environment Files
1. Create `.env.example` in repo root:
   ```env
   SUPABASE_URL=
   SUPABASE_ANON_KEY=
   SUPABASE_SERVICE_ROLE_KEY=
   JWT_SECRET=
   LOG_LEVEL=
   ```
2. Add `.env.local` (ignored) with real values.
3. Share only the placeholder file; secrets remain private.

---

## 5. Connect Vercel ("Wursel")
1. Create a new Vercel project linked to `broad-backend`.
2. Framework preset: **Other**; leave build/output blank until code exists.
3. Add environment variables under Project Settings:
   - `SUPABASE_URL`
   - `SUPABASE_ANON_KEY`
   - `SUPABASE_SERVICE_ROLE_KEY` (mark as Secret)
   - `JWT_SECRET`
   - `LOG_LEVEL` (default `info`)
4. Ensure preview deployments are on for PR validation.

---

## 6. Handoff Checklist
Once steps 1–5 are done, provide the backend engineer/agent with:
- Local repo path
- Confirmation that Supabase env values exist (no actual secrets)
- Any SQL/Migration files generated
- Confirmation Vercel is linked and environment variables set

---

## 7. Project Scaffolding Blueprint
The implementer should create the following structure and scripts after checkout:

```
broad-backend/
├── docs/
│   └── openapi.yaml
├── src/
│   ├── config/
│   │   ├── env.ts
│   │   └── supabase.ts
│   ├── routes/
│   │   ├── auth.routes.ts
│   │   ├── rides.routes.ts
│   │   ├── profiles.routes.ts
│   │   └── garage.routes.ts
│   ├── services/
│   │   ├── auth.service.ts
│   │   ├── rides.service.ts
│   │   ├── profiles.service.ts
│   │   └── garage.service.ts
│   ├── repositories/
│   │   ├── rides.repository.ts
│   │   └── garage.repository.ts
│   ├── schemas/
│   │   ├── rides.schema.ts
│   │   ├── profiles.schema.ts
│   │   └── garage.schema.ts
│   ├── middleware/
│   │   └── auth.ts
│   ├── utils/
│   │   ├── logger.ts
│   │   └── responses.ts
│   ├── types/
│   │   ├── dto.ts
│   │   └── supabase.ts
│   └── server.ts
├── supabase/
│   ├── config.toml
│   └── migrations/
│       └── 202406110001_initial.sql
├── package.json
├── tsconfig.json
├── .eslintrc.cjs
└── .prettierrc
```

### Essential Dependencies
```
npm install fastify @fastify/cors @fastify/jwt @fastify/swagger @fastify/swagger-ui zod supabase-js pino uuid
npm install -D typescript tsx ts-node-dev eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin prettier jest ts-jest @types/jest @types/node supertest @types/supertest
```

### NPM Scripts Example
```json
{
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/server.js",
    "lint": "eslint 'src/**/*.{ts,tsx}'",
    "format": "prettier --check .",
    "test": "jest",
    "supabase:migrate": "supabase db push"
  }
}
```

---

## 8. Shared Type Contracts & API Shape
Consistency between Expo frontend and backend is critical. The frontend expects JSON responses shaped like `ApiResponse<T>` from `src/services/api.ts`.

### 8.1 Base Response Wrapper
```ts
// src/types/dto.ts
export interface ApiResponse<T> {
  data: T;
  success: boolean;
  message?: string;
}

export const wrap = <T>(data: T, message?: string): ApiResponse<T> => ({
  data,
  success: true,
  message,
});

export const errorResponse = (message: string, code?: string) => ({
  success: false,
  message,
  code,
});
```
Fastify handlers should return `reply.send(wrap(payload))` to match frontend expectations.

### 8.2 Domain DTOs (used by backend + shared via OpenAPI/SDK)
```ts
// src/types/dto.ts
export interface ProfileDTO {
  id: string;
  handle: string | null;
  displayName: string;
  bio: string | null;
  avatarUrl: string | null;
  countryCode: string | null;
  phoneNumber: string | null;
  role: 'rider' | 'admin';
  createdAt: string;
  updatedAt: string;
}

export interface RideDTO {
  id: string;
  creatorId: string;
  title: string;
  tagline: string | null;
  routeSummary: string | null;
  startsAt: string;
  meetupLocation: {
    lat: number;
    lng: number;
    address: string;
  } | null;
  pace: 'cruise' | 'group' | 'spirited';
  experienceLevel: 'novice' | 'intermediate' | 'advanced';
  maxRiders: number;
  status: 'scheduled' | 'in_progress' | 'completed' | 'cancelled';
  createdAt: string;
  updatedAt: string;
  bookings: RideBookingSummaryDTO[];
}

export interface RideBookingSummaryDTO {
  id: string;
  riderId: string;
  status: 'pending' | 'confirmed' | 'waitlisted' | 'cancelled';
}

export interface GarageDTO {
  id: string;
  ownerId: string;
  label: string;
  createdAt: string;
  motorcycles: MotorcycleDTO[];
}

export interface MotorcycleDTO {
  id: string;
  garageId: string;
  make: string;
  model: string;
  year: number | null;
  nickname: string | null;
  odometerKm: number | null;
  lastServicedAt: string | null;
  deletedAt: string | null;
  maintenanceLogs: MaintenanceLogDTO[];
}

export interface MaintenanceLogDTO {
  id: string;
  motorcycleId: string;
  performedAt: string;
  description: string;
  cost: number | null;
  notes: string | null;
  createdAt: string;
}
```
Keep DTO names aligned with frontend expectations; TypeScript casing matches camelCase used across the app.

### 8.3 Zod Schemas for Validation
```ts
// src/schemas/profiles.schema.ts
import { z } from 'zod';

export const CreateProfileSchema = z.object({
  handle: z.string().min(3).max(30).regex(/^[a-z0-9_]+$/).optional(),
  displayName: z.string().min(2).max(60),
  countryCode: z.string().length(2).optional(),
  phoneNumber: z.string().min(8).max(20).optional(),
});

export const UpdateProfileSchema = CreateProfileSchema.extend({
  bio: z.string().max(280).optional(),
  avatarUrl: z.string().url().optional(),
});
```

```ts
// src/schemas/rides.schema.ts
export const CreateRideSchema = z.object({
  title: z.string().min(3).max(80),
  tagline: z.string().max(120).optional(),
  routeSummary: z.string().max(500).optional(),
  startsAt: z.string().datetime(),
  meetupLocation: z
    .object({
      lat: z.number().min(-90).max(90),
      lng: z.number().min(-180).max(180),
      address: z.string().max(200),
    })
    .optional(),
  pace: z.enum(['cruise', 'group', 'spirited']),
  experienceLevel: z.enum(['novice', 'intermediate', 'advanced']),
  maxRiders: z.number().int().min(2).max(50),
  segments: z
    .array(
      z.object({
        sequence: z.number().int().min(1),
        note: z.string().max(140),
        distanceKm: z.number().min(0),
      })
    )
    .optional(),
});

export const RideQuerySchema = z.object({
  limit: z.coerce.number().int().min(1).max(50).default(20),
  cursor: z.string().uuid().optional(),
  creatorId: z.string().uuid().optional(),
  search: z.string().max(80).optional(),
});
```

---

## 9. Example Implementations
These snippets illustrate how the backend should be wired. They can be used verbatim or adapted to fit the final codebase.

### 9.1 Environment Loader
```ts
// src/config/env.ts
import { config } from 'dotenv';

if (process.env.NODE_ENV !== 'production') {
  config({ path: '.env.local' });
}

const requiredVars = ['SUPABASE_URL', 'SUPABASE_ANON_KEY', 'SUPABASE_SERVICE_ROLE_KEY', 'JWT_SECRET'];

requiredVars.forEach((key) => {
  if (!process.env[key]) {
    throw new Error(`Missing environment variable: ${key}`);
  }
});

export const env = {
  supabaseUrl: process.env.SUPABASE_URL!,
  supabaseAnonKey: process.env.SUPABASE_ANON_KEY!,
  supabaseServiceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY!,
  jwtSecret: process.env.JWT_SECRET!,
  logLevel: process.env.LOG_LEVEL ?? 'info',
};
```

### 9.2 Supabase Client Factory
```ts
// src/config/supabase.ts
import { createClient } from '@supabase/supabase-js';
import { env } from './env';

export const supabaseAdmin = createClient(env.supabaseUrl, env.supabaseServiceRoleKey, {
  auth: { persistSession: false },
});
```

### 9.3 Fastify Server Entry
```ts
// src/server.ts
import Fastify from 'fastify';
import cors from '@fastify/cors';
import jwt from '@fastify/jwt';
import swagger from '@fastify/swagger';
import swaggerUi from '@fastify/swagger-ui';
import { env } from './config/env';
import { router as profileRoutes } from './routes/profiles.routes';
import { router as rideRoutes } from './routes/rides.routes';
import { router as garageRoutes } from './routes/garage.routes';
import { logger } from './utils/logger';

const app = Fastify({ logger });

app.register(cors, { origin: true });
app.register(jwt, { secret: env.jwtSecret });
app.decorate('authenticate', async function (request) {
  await request.jwtVerify();
});

app.register(swagger, {
  openapi: {
    info: { title: 'Broad Backend API', version: '0.1.0' },
    components: { securitySchemes: { bearerAuth: { type: 'http', scheme: 'bearer' } } },
  },
});
app.register(swaggerUi, { routePrefix: '/docs' });

app.register(profileRoutes, { prefix: '/profiles' });
app.register(rideRoutes, { prefix: '/rides' });
app.register(garageRoutes, { prefix: '/garage' });

app.get('/health', async () => ({ status: 'ok' }));

app.listen({ port: Number(process.env.PORT ?? 3000), host: '0.0.0.0' });
```

### 9.4 Profile Routes Example
```ts
// src/routes/profiles.routes.ts
import { FastifyInstance } from 'fastify';
import { CreateProfileSchema, UpdateProfileSchema } from '../schemas/profiles.schema';
import { wrap } from '../utils/responses';
import { ProfilesService } from '../services/profiles.service';

export async function router(app: FastifyInstance) {
  const service = new ProfilesService();

  app.post('/', { preValidation: [app.authenticate] }, async (request, reply) => {
    const payload = CreateProfileSchema.parse(request.body);
    const userId = request.user.sub as string;
    const profile = await service.createProfile(userId, payload);
    return reply.send(wrap(profile, 'Profile created'));
  });

  app.patch('/me', { preValidation: [app.authenticate] }, async (request, reply) => {
    const payload = UpdateProfileSchema.parse(request.body);
    const userId = request.user.sub as string;
    const profile = await service.updateProfile(userId, payload);
    return reply.send(wrap(profile, 'Profile updated'));
  });

  app.get('/me', { preValidation: [app.authenticate] }, async (request, reply) => {
    const userId = request.user.sub as string;
    const profile = await service.getProfile(userId);
    return reply.send(wrap(profile));
  });
}
```

### 9.5 Ride Creation Service Snippet
```ts
// src/services/rides.service.ts
import { supabaseAdmin } from '../config/supabase';
import { CreateRideSchema } from '../schemas/rides.schema';
import { RideDTO } from '../types/dto';

export class RidesService {
  async createRide(creatorId: string, body: unknown): Promise<RideDTO> {
    const payload = CreateRideSchema.parse(body);

    const { data: ride, error } = await supabaseAdmin
      .from('rides')
      .insert({
        creator_id: creatorId,
        title: payload.title,
        tagline: payload.tagline,
        route_summary: payload.routeSummary,
        starts_at: payload.startsAt,
        meetup_location: payload.meetupLocation ?? null,
        pace: payload.pace,
        experience_level: payload.experienceLevel,
        max_riders: payload.maxRiders,
      })
      .select('*')
      .single();

    if (error) throw new Error(error.message);

    if (payload.segments?.length) {
      const segments = payload.segments.map((segment) => ({
        ride_id: ride.id,
        sequence: segment.sequence,
        note: segment.note,
        distance_km: segment.distanceKm,
      }));
      const { error: segError } = await supabaseAdmin.from('ride_segments').insert(segments);
      if (segError) throw new Error(segError.message);
    }

    await supabaseAdmin
      .from('bookings')
      .insert({ ride_id: ride.id, rider_id: creatorId, status: 'confirmed' });

    return this.mapRideToDto(ride);
  }

  private mapRideToDto(row: any): RideDTO {
    return {
      id: row.id,
      creatorId: row.creator_id,
      title: row.title,
      tagline: row.tagline,
      routeSummary: row.route_summary,
      startsAt: row.starts_at,
      meetupLocation: row.meetup_location,
      pace: row.pace,
      experienceLevel: row.experience_level,
      maxRiders: row.max_riders,
      status: row.status,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      bookings: [],
    };
  }
}
```

### 9.6 Garage Repository Snippet
```ts
// src/repositories/garage.repository.ts
import { supabaseAdmin } from '../config/supabase';
import { GarageDTO } from '../types/dto';

export class GarageRepository {
  async getGarageByOwner(ownerId: string): Promise<GarageDTO | null> {
    const { data, error } = await supabaseAdmin
      .from('garages')
      .select('
        id,
        owner_id,
        label,
        created_at,
        motorcycles:motorcycles(
          id,
          garage_id,
          make,
          model,
          year,
          nickname,
          odometer_km,
          last_serviced_at,
          deleted_at,
          maintenance_logs:maintenance_logs(
            id,
            motorcycle_id,
            performed_at,
            description,
            cost,
            notes,
            created_at
          )
        )
      ')
      .eq('owner_id', ownerId)
      .maybeSingle();

    if (error) throw new Error(error.message);
    if (!data) return null;

    return {
      id: data.id,
      ownerId: data.owner_id,
      label: data.label,
      createdAt: data.created_at,
      motorcycles: (data.motorcycles ?? []).map((m: any) => ({
        id: m.id,
        garageId: m.garage_id,
        make: m.make,
        model: m.model,
        year: m.year,
        nickname: m.nickname,
        odometerKm: m.odometer_km,
        lastServicedAt: m.last_serviced_at,
        deletedAt: m.deleted_at,
        maintenanceLogs: (m.maintenance_logs ?? []).map((log: any) => ({
          id: log.id,
          motorcycleId: log.motorcycle_id,
          performedAt: log.performed_at,
          description: log.description,
          cost: log.cost,
          notes: log.notes,
          createdAt: log.created_at,
        })),
      })),
    };
  }
}
```

### 9.7 OpenAPI Contract
Document every endpoint in `docs/openapi.yaml`. Example excerpt:

```yaml
openapi: 3.1.0
info:
  title: Broad Backend API
  version: 0.1.0
paths:
  /profiles/me:
    get:
      security:
        - bearerAuth: []
      responses:
        '200':
          description: Current profile
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProfileResponse'
components:
  schemas:
    ProfileResponse:
      type: object
      properties:
        success:
          type: boolean
          example: true
        data:
          $ref: '#/components/schemas/Profile'
    Profile:
      type: object
      properties:
        id:
          type: string
          format: uuid
        displayName:
          type: string
```
Export the schema to share with the frontend or generate SDKs via `openapi-typescript`.

---

## 10. Feature Development Roadmap (Detailed)
Each subsection includes data model notes, API endpoints, validation, and testing expectations. Use the DTOs and schemas above.

### 10.1 Profiles
- **Endpoints**
  - `POST /profiles` → create profile record after Supabase auth signup.
  - `GET /profiles/me` → fetch current profile.
  - `PATCH /profiles/me` → update profile fields.
- **Frontend Contract**: Map response payloads to `ProfileDTO` so the Expo app can hydrate Zustand store.
- **Testing**: Integration tests for create/update flows; ensure RLS prevents another user accessing `profiles/:id`.
- **Sample Test (Jest)**
  ```ts
  it('updates profile bio', async () => {
    const token = await loginAs('user@example.com');
    const response = await app.inject({
      method: 'PATCH',
      url: '/profiles/me',
      headers: { authorization: `Bearer ${token}` },
      payload: { displayName: 'Pallav', bio: 'Track rider' },
    });
    expect(response.statusCode).toBe(200);
    const body = response.json();
    expect(body.data.bio).toBe('Track rider');
  });
  ```

### 10.2 Trip / Ride Lifecycle
- **Endpoints**
  - `POST /rides` (create)
  - `GET /rides` (list)
  - `GET /rides/:id`
  - `POST /rides/:id/book`
  - `POST /rides/:id/cancel`
- **DB Operations**: Insert ride, optional segments, auto-create booking for creator, maintain capacity rules.
- **Realtime**: Publish `bookings` table changes via Supabase Realtime; backend may expose signed token endpoint.
- **Testing**: Unit tests for waitlist logic; integration tests for create/list/book flows; verify invalid data returns 400.
- **Example Waitlist Logic**
  ```ts
  const { count } = await supabaseAdmin
    .from('bookings')
    .select('*', { count: 'exact', head: true })
    .eq('ride_id', rideId)
    .eq('status', 'confirmed');

  const nextStatus = count >= ride.max_riders ? 'waitlisted' : 'confirmed';
  ```

### 10.3 Garage & Maintenance
- **Endpoints**
  - `GET /garage` → auto-create garage if missing.
  - `POST /garage/motorcycles`
  - `PATCH /garage/motorcycles/:id`
  - `DELETE /garage/motorcycles/:id`
  - `POST /garage/motorcycles/:id/maintenance`
- **Validation**: Year range 1960–current, VIN optional but unique, odometer must be >= 0.
- **Soft Deletes**: Set `deleted_at` instead of hard delete; filter in queries.
- **Testing**: Ensure owner-only access via RLS; confirm maintenance logs attach to proper motorcycle.

### 10.4 Notifications (Phase 2)
- **Table**: `notifications (id, recipient_id, type, payload, read_at, created_at)`.
- **Endpoints**: `GET /notifications`, `POST /notifications/read`.
- **Push**: Store Expo push token in `profiles.expo_push_token`; queue sends via Expo SDK.
- **Future**: Offload long-running sends to Vercel cron or Fly worker.

### 10.5 Admin & Analytics (Phase 2+)
- Role-based access via `profiles.role` (enum: `rider`, `moderator`, `admin`).
- Admin endpoints under `/admin` prefix; require `request.user.role === 'admin'`.
- Metrics queries (rides per week, active riders) using Supabase SQL views.

### 10.6 Cross-Cutting Requirements
- **Error Handling**: Global Fastify error handler returning `{ success: false, message, code }`.
- **Logging**: Pino logger with child loggers per request; include request ID.
- **Observability**: Add request timing metrics; integrate Vercel monitoring or Logflare as load grows.
- **Docs**: Update OpenAPI spec with every change; automate using `npm run generate:openapi` (e.g., `openapi-typescript docs/openapi.yaml --output src/types/api.d.ts`).
- **CI/CD**: GitHub Actions pipeline running lint, test, and `supabase db lint`. Ensure Vercel deploy uses cached build output.

---

## 11. Completion Criteria (MVP Ready)
- Infrastructure: repo, Supabase migrations, env vars, CI/CD, Vercel deploy all configured.
- Features: Profiles, Rides/Bookings, Garage flows delivered with tests and documented endpoints.
- Expo App: Can log in, manage profile, create/join rides, manage garage, and receive realtime updates.
- Documentation: `BACKEND_SETUP.md` + OpenAPI spec reflect current behavior; README updated with run instructions.

Once these boxes are checked, future iterations (payments, analytics dashboards, background workers) can extend the system without rework.

---

## 12. Suggested Next Steps After MVP
1. Integrate payments (Stripe) for paid rides.
2. Add geofencing services for live ride tracking.
3. Implement role-based moderation tools (ride approvals, report handling).
4. Introduce analytics dashboards for ride performance.
5. Plan background worker infrastructure (Fly.io machines, QStash, or Upstash Redis queues).

This playbook hands off everything required to deliver the backend in a predictable, well-documented way.
